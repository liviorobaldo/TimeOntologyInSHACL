@prefix : <http://robaldoandbatsakis/timeontologyshacl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix time: <http://www.w3.org/2006/time#> .

#defines all prefixes used in at least one sh:rule below
:PrefixesEmbeddedSPARQLRules sh:declare 
	[sh:prefix"rdf";sh:namespace"http://www.w3.org/1999/02/22-rdf-syntax-ns#"^^xsd:anyURI],
	[sh:prefix"rdfs";sh:namespace"http://www.w3.org/2000/01/rdf-schema#"^^xsd:anyURI],
	[sh:prefix"xsd";sh:namespace"http://www.w3.org/2001/XMLSchema#"^^xsd:anyURI],
	[sh:prefix"time";sh:namespace"http://www.w3.org/2006/time#"^^xsd:anyURI],
	[sh:prefix"";sh:namespace"http://robaldoandbatsakis/timeontologyshacl#"^^xsd:anyURI].


##############################################################################################################################################
#
#	RDF schema inferences: rdfs:subclassOf, rdfs:domain, rdfs:range, and rdfs:subPropertyOf.
#
##############################################################################################################################################

#The next four rules implement rdfs:subClassOf, rdfs:domain, rdfs:range, and rdfs:subPropertyOf.
#These four rules might be avoided by extending the other rules below; for instance, we could avoid the rule implementing rdfs:subClassOf 
#by replacing "rdf:type" with "rdf:type/rdfs:subClassOf*" in all other rules below. Nevertheless, of course, this would be much more verbose.

[rdf:type sh:NodeShape;
	sh:targetSubjectsOf rdfs:subClassOf;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?s rdf:type ?c}WHERE{$this rdfs:subClassOf+ ?c. ?s rdf:type $this}"""]].
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf rdfs:domain;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?s rdf:type ?c}WHERE{$this rdfs:domain ?c. ?s $this ?o}"""]].
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf rdfs:range;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?o rdf:type ?c}WHERE{$this rdfs:range ?c. ?s $this ?o}"""]].
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf rdfs:subPropertyOfaa;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?s ?p ?o}WHERE{$this rdfs:subPropertyOf ?p. ?s $this ?o}"""]].


##############################################################################################################################################
#
#	Inverse relations
#
##############################################################################################################################################

#The next rules implements all inverse relations encoded in the Time Ontology.
[rdf:type sh:NodeShape;
	sh:targetClass time:TemporalEntityaaa;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?pi2 ?pi $this}
						WHERE{$this ?p ?pi2.
						      BIND(IF(?p=time:after, time:before,
								   IF(?p=time:before, time:after,
								   IF(?p=time:intervalAfter, time:intervalBefore,
								   IF(?p=time:intervalBefore, time:intervalAfter,								   
								   IF(?p=time:intervalContains, time:intervalDuring,
								   IF(?p=time:intervalDuring, time:intervalContains,
								   IF(?p=time:intervalFinishedBy, time:intervalFinishes,
								   IF(?p=time:intervalFinishes, time:intervalFinishedBy,
								   IF(?p=time:intervalMeets, time:intervalMetBy,
								   IF(?p=time:intervalMetBy, time:intervalMeets,
								   IF(?p=time:intervalOverlappedBy, time:intervalOverlaps,
								   IF(?p=time:intervalOverlaps, time:intervalOverlappedBy,
								   IF(?p=time:intervalStartedBy, time:intervalStarts,
								   IF(?p=time:intervalStarts, time:intervalStartedBy, 
								   IF(?p=time:intervalEquals, time:intervalEquals, :nothing))))))))))))))) AS ?pi)
							  FILTER(?pi!=:nothing)}"""]].

##############################################################################################################################################
#
#	Rules on time:hasBeginning and time:hasEnd.
#
##############################################################################################################################################

#The next two rule searches for time:TemporalEntity(s) that begin or end at a given time:Instant. If this time:Instant is connected through a 
#chain of time:hasBeginning|time:hasEnd with other time:Instant(s), then the time:TemporalEntity also begins or ends at these time:Instant(s).
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:hasBeginning;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this time:hasBeginning ?i}
						WHERE{$this time:hasBeginning/(time:hasBeginning|time:hasEnd)+ ?i}"""]].
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:hasEnd;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this time:hasEnd ?i}
						WHERE{$this time:hasEnd/(time:hasBeginning|time:hasEnd)+ ?i}"""]].

#The next rule infers the same extra connections of the previous ones but in backward direction. For each time:Instant that leads to another 
#time:Instant through a chain of time:hasBeginning|time:hasEnd, the next rule infers that the latter begins and ends at the former.
[rdf:type sh:NodeShape;
	sh:targetClass time:Instant;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?i time:hasBeginning $this. ?i time:hasEnd $this}
						WHERE{$this (time:hasBeginning|time:hasEnd)+ ?i}"""]].

#The first of the next two rules infers that whenever a time:TemporalEntity begins at two different time:Instant(s), these two time:Instant(s)
#are actually the same, therefore time:hasBeginning is inferred among them. The second of the next two rules does the same but on time:hasEnd.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:hasBeginning;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?i1 time:hasBeginning ?i2}
						WHERE{$this time:hasBeginning ?i1. $this time:hasBeginning ?i2}"""]].
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:hasBeginning;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?i1 time:hasEnd ?i2}
						WHERE{$this time:hasEnd ?i1. $this time:hasEnd ?i2}"""]].

#The next rule infers a time:TemporalEntity as a time:Instant if it begins and ends at the same time:Instant (or at two time:Instant(s) associated
#with the same xsd:dateTime value).
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:hasBeginning;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this a time:Instant}
						WHERE{{$this time:hasBeginning ?b. $this time:hasEnd ?b}UNION
							  {$this time:hasBeginning/time:inXSDDateTime ?dtb. $this time:hasEnd/time:inXSDDateTime ?dte. FILTER(?dtb=?dte)}}"""]].


##############################################################################################################################################
#
#	Rules on time:before, time:after, and time:inside (the rules on time:before are defined below together with the rules associated
#	with the properties that denote Allen's temporal relations).
#
##############################################################################################################################################

#The next rule, in cases where two time:TemporalEntity(s) are connected by time:before and one of the two is connected to other 
#time:Instant(s) through time:hasBeginning|time:inside|time:hasEnd, infers the Cartesian product between the two time:TemporalEntity(s) 
#and any time:Instant connected to them through time:hasBeginning|time:inside|time:hasEnd.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:before;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
	sh:construct """CONSTRUCT{?i1 time:before ?te2. ?i1 time:before ?i2}
					WHERE{$this time:before ?te2.
						  {BIND($this AS ?i1)}UNION{$this (time:hasBeginning|time:inside|time:hasEnd) ?i1}
						  {BIND(?te2 AS ?i2)}UNION{?te2 (time:hasBeginning|time:inside|time:hasEnd) ?i2}}"""]].

#The next rule, in cases where two time:TemporalEntity(s) are such that one of the two is connected to a time:Instant through the property
#time:hasEnd and this time:Instant is in turn connected to the other time:TemporalEntity through the property time:before, infers that 
#the first time:TemporalEntity is also connected to the second one through the property time:before.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:before;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
	sh:construct """CONSTRUCT{?te1 time:before ?te}WHERE{$this time:before ?te. $this ^time:hasEnd ?te1}"""]].
	
#The next rule, in cases where two time:TemporalEntity(s) are such that one of the two is connected to a time:Instant through the property
#time:before and the other time:TemporalEntity is connected to the same time:Instant through the property time:hasBeginning, infers that 
#the first time:TemporalEntity is also connected to the second one through the property time:before. 
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:before;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
	sh:construct """CONSTRUCT{$this time:before ?te2}WHERE{$this time:before ?te. ?te ^time:hasBeginning ?te2}"""]].

#The next two rules, in cases where time:Interval is connected to a time:Instant through the property time:inside, infers that the time:Instant 
#connected to the former through the property time:hasBeginning (if any) occurs before the latter and that the latter occurs before the 
#time:Instant connected to the former through the property time:hasEnd.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:inside;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?b time:before ?i}WHERE{$this time:hasBeginning ?b. $this time:inside ?i}"""]].
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:inside;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?i time:before ?e}WHERE{$this time:hasEnd ?e. $this time:inside ?i}"""]].


##############################################################################################################################################
#
#	Rules on time:ProperInterval and the Time Ontology's properties denoting Allen's temporal relations.
#	In particular, this section contains rules that infer all time:before properties between the time:Instant(s) occurring within
#	two time:ProperInterval connected by the properties denoting Allen's temporal relations.
#
##############################################################################################################################################

#The next rule infers that the time:Instant at which a time:ProperInterval begins occurs before the one at which the time:ProperInterval ends.
[rdf:type sh:NodeShape;
	sh:targetClass time:ProperInterval;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?b time:before ?e}
						WHERE{$this time:hasBeginning ?b. $this time:hasEnd ?e}"""]].

#---------------------------------------------------------------------------------------------------------------------------------------------
# time:intervalBefore and time:intervalAfter
# These two properties are rdfs:subPropertyOf of time:before and time: after respectively. The rules below assert the property time:before
# between two time:TemporalEntity(s) in cases the latter are also connected by the property time:before.
#---------------------------------------------------------------------------------------------------------------------------------------------

#The next rule infers the property time:intervalBefore between two time:TemporalEntity(s) connected through the property time:before
#in cases where both these time:TemporalEntity(s) are also instantes of time:ProperInterval.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:before;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this time:intervalBefore ?pi2}
						WHERE{$this time:before ?pi2; rdf:type time:ProperInterval. ?pi2 rdf:type time:ProperInterval}"""]].

#---------------------------------------------------------------------------------------------------------------------------------------------
# time:intervalStarts and time:intervalStartedBy
# These two properties are the inverse of one another. Therefore, it is enough to focus only on one of them (time:intervalStarts) while we
# define a rule that converts every triple on time:intervalStartedBy into the inverse triple in time:intervalStarts. The Time Ontology defines
# time:intervalStarts as "If a proper interval T1 is intervalStarts another proper interval T2, then the beginning of T1 is coincident with the
# beginning of T2, and the end of T1 is before the end of T2.". Two SHACL-SPARQL rules are defined to properly implement this definition.
#---------------------------------------------------------------------------------------------------------------------------------------------

#The next rule, in cases where the two intervals occur as subject of time:hasBeginning, infers that the two objects of time:hasBeginning are
#the same time:Instant, i.e., they begin and end of one another.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalStarts;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?b1 time:hasBeginning ?b2. ?b2 time:hasBeginning ?b1. ?b1 time:hasEnd ?b2. ?b2 time:hasEnd ?b1}
						WHERE{$this time:intervalStarts ?te2. $this time:hasBeginning ?b1. ?te2 time:hasBeginning ?b2}"""]].

#The next rule infers that the interval as subject of time:intervalStarts occurs before the end of its object. Note that the 
#definition of time:intervalStarts says that the end of that interval occur before the end of time:intervalStarts's object, but it follows 
#that the whole interval does.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalStarts;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this time:before ?e2}
						WHERE{$this time:intervalStarts/time:hasEnd ?e2}"""]].

#The next rule infers that the beginning of time:intervalStarts's subject occurs before the end and every time:Instant inside its object.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalStarts;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?b1 time:before ?i2}
						WHERE{$this time:intervalStarts/(time:hasEnd|time:inside) ?i2. $this time:hasBeginning ?b1}"""]].

#---------------------------------------------------------------------------------------------------------------------------------------------
# time:intervalOverlaps and time:intervalOverlappedBy
# These two properties are the inverse of one another. Therefore, it is enough to focus only on one of them (time:intervalOverlaps) while we
# define a rule that converts every triple on time:intervalOverlappedBy into the inverse triple in time:intervalOverlaps. The Time Ontology
# defines time:intervalOverlaps as "If a proper interval T1 is intervalOverlaps another proper interval T2, then the beginning of T1 is   
# before the beginning of T2, the end of T1 is after the beginning of T2, and the end of T1 is before the end of T2.".
#---------------------------------------------------------------------------------------------------------------------------------------------

#The next three rule implement 1:1 the definition of the time:intervalOverlaps property. Note that the first rule also consider the instant
#that ends, as well as those that occur inside, the object of time:intervalOverlaps.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalOverlaps;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?b1 time:before ?te2}
						WHERE{$this time:intervalOverlaps ?te2. $this time:hasBeginning ?b1}"""]].
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalOverlaps;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?b2 time:before ?e1}
						WHERE{$this time:intervalOverlaps/time:hasBeginning ?b2. $this time:hasEnd ?e1}"""]].
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalOverlaps;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?e1 time:before ?e2}
						WHERE{$this time:intervalOverlaps/time:hasEnd ?e2. $this time:hasEnd ?e1}"""]].

#---------------------------------------------------------------------------------------------------------------------------------------------
# time:intervalMeets and time:intervalMetBy
# These two properties are the inverse of one another. Therefore, it is enough to focus only on one of them (time:intervalMeets) while we
# define a rule that converts every triple on time:intervalMetBy into the inverse triple in time:intervalMeets. The Time Ontology
# defines time:intervalMeets as "If a proper interval T1 is intervalMeets another proper interval T2, then the end of T1 is coincident with 
# the beginning of T2.".
#---------------------------------------------------------------------------------------------------------------------------------------------

#The next rule infers that the end of the subject of time:intervalMeets and the beginning of its object are the same time:Instant. 
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalMeets;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
	sh:construct """CONSTRUCT{?e1 time:hasBeginning ?b2. ?b2 time:hasBeginning ?e1. ?e1 time:hasEnd ?b2. ?b2 time:hasEnd ?e1}
					WHERE{$this time:intervalMeets/time:hasBeginning ?b2. $this time:hasEnd ?e1}"""]].
					
#The next rule infers that every instant that either begins or occurs inside the interval as subject of time:intervalMeets also occurs 
#before the other interval.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalMeets;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?i time:before ?te2}
						WHERE{$this time:intervalMeets ?te2. $this time:hasBeginning|time:inside ?i}"""]].

#The next rule infers that the interval as subject of time:intervalMeets occurs before every time:Instant that either ends or occurs inside 
#the interval its object.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalMeets;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this time:before ?i}
						WHERE{$this time:intervalMeets/(time:hasEnd|time:inside) ?i}"""]].

#---------------------------------------------------------------------------------------------------------------------------------------------
# time:intervalFinishes and time:intervalFinishedBy
# These two properties are the inverse of one another. Therefore, it is enough to focus only on one of them (time:intervalFinishes) while we
# define a rule that converts every triple on time:intervalFinishedBy into the inverse triple in time:intervalFinishes. The Time Ontology
# defines time:intervalFinishes as "If a proper interval T1 is intervalFinishes another proper interval T2, then the beginning of T1 is after 
# the beginning of T2, and the end of T1 is coincident with the end of T2.".
#---------------------------------------------------------------------------------------------------------------------------------------------

#The next rule, in cases where the two intervals occur as subject of time:hasEnd, infers that the two objects of time:hasEnd are the same
#time:Instant, i.e., they begin and end of one another.					
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalFinishes;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?e1 time:hasBeginning ?e2. ?e2 time:hasBeginning ?e1. ?e1 time:hasEnd ?e2. ?e2 time:hasEnd ?e1}
						WHERE{$this time:intervalFinishes/time:hasEnd ?e2. $this time:hasEnd ?e1}"""]].

#The next rule infers that the beginning of the object of time:intervalStarts occurs before the interval as its subject. Note that the 
#definition of time:intervalFinishes only says that the beginning of that interval occur after the beginning of time:intervalStarts's object, 
#but it follows that the whole interval does.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalFinishes;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?b2 time:before $this}
						WHERE{$this time:intervalFinishes/time:hasBeginning ?b2}"""]].

#The next rule infers that the beginning and every time:Instant inside time:intervalFinishes's subject occurs before the end of its object.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalFinishes;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?i1 time:before ?e2}
						WHERE{$this time:intervalFinishes/time:hasEnd ?e2. $this (time:hasBeginning|time:inside) ?i1}"""]].


#---------------------------------------------------------------------------------------------------------------------------------------------
# time:intervalDuring and time:intervalContains
# These two properties are the inverse of one another. Therefore, it is enough to focus only on one of them (time:intervalContains) while
# we define a rule that converts every triple on time:intervalDuring into the inverse triple in time:intervalContains. The Time Ontology
# defines time:intervalContains as "If a proper interval T1 is intervalContains another proper interval T2, then the beginning of T1 is 
# before the beginning of T2, and the end of T1 is after the end of T2.".
#---------------------------------------------------------------------------------------------------------------------------------------------

#The next two rules implement the definition of time:intervalDuring by inferring that the beginning of time:intervalDuring's object
#occurs before time:intervalDuring's subject and the latter occurs before the end of time:intervalDuring.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalDuring;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?b2 time:before $this}
						WHERE{$this time:intervalDuring/time:hasBeginning ?b2}"""]].
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalDuring;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this time:before ?e2}
						WHERE{$this time:intervalDuring/time:hasEnd ?e2}"""]].

#---------------------------------------------------------------------------------------------------------------------------------------------
# time:intervalEquals
# Two time:ProperInterval(s) connected by this property are the same time:ProperInterval: their begin and end time:Instance coincide.
#---------------------------------------------------------------------------------------------------------------------------------------------

#The next two rules infer that the beginnings and the ends of two time:ProperInterval(s) connected by time:intervalEquals coincide.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalEquals;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?b1 time:hasBeginning ?b2. ?b2 time:hasBeginning ?b1. ?b1 time:hasEnd ?b2. ?b2 time:hasEnd ?b1}
						WHERE{$this time:intervalEquals/time:hasBeginning ?b2. $this time:hasBeginning ?b1}"""]].
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalEquals;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?e1 time:hasBeginning ?e2. ?e2 time:hasBeginning ?e1. ?e1 time:hasEnd ?e2. ?e2 time:hasEnd ?e1}
						WHERE{$this time:intervalEquals/time:hasEnd ?e2. $this time:hasEnd ?e1}"""]].

#The next rule infer that the beginning of one of the two time:ProperInterval(s) occur before the end of the other one.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalEquals;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?b time:before ?e}
						WHERE{$this time:intervalEquals ?te2. 
							  {$this time:hasBeginning ?b. ?te2 time:hasEnd ?e}UNION{?te2 time:hasBeginning ?b. $this time:hasEnd ?e}}"""]].

#---------------------------------------------------------------------------------------------------------------------------------------------
# time:intervalIn
# The object of time:ProperInterval(s) is included in its subject. Furthermore, the two time:ProperInterval(s) have one extreme, i.e., either 
# the beginnings or the ends in common, but not both. The rules below infer that if one pair of extremes denote the same time:Instant, then
# the time:before property hold between the other two extremes and viceversa.
#---------------------------------------------------------------------------------------------------------------------------------------------

#The next rule checks whether the beginnings of the two time:ProperInterval(s) denote the same time:Instant; if so, it infers that the two 
#time:ProperInterval(s) are also related through the property time:intervalStarts.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalIn;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this time:intervalStarts ?te2}
						WHERE{$this time:intervalIn ?te2. $this time:hasBeginning ?b1. ?te2 time:hasBeginning ?b2.
							  {?b1 time:inXSDDateTime ?dt1. ?b2 time:inXSDDateTime ?dt2. FILTER(?dt1=?dt2)}UNION{?b1 time:hasBeginning ?b2}}"""]].
							  
#The next rule checks whether the ends of the two intervals denote the same time:Instant; if so, it infers that the two 
#time:ProperInterval(s) are also related through the property time:intervalFinishes.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalIn;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this time:intervalFinishes ?te2}
						WHERE{$this time:intervalIn ?te2.
							  $this time:hasEnd ?e1. ?te2 time:hasEnd ?e2.
							  {?e1 time:inXSDDateTime ?dt1. ?e2 time:inXSDDateTime ?dt2. FILTER(?dt1=?dt2)}UNION{?e1 time:hasBeginning ?e2}}"""]].

#The next rule checks whether the beginning of of time:intervalIn's object occurs before the beginning of time:intervalIn's subject and 
#the end of time:intervalIn's subject occurs before the end of time:intervalIn's object; if so, it infers that the two time:ProperInterval(s)
#are also related through the property time:intervalDuring.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalIn;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this time:intervalDuring ?te2}
						WHERE{$this time:intervalIn ?te2. 
							  $this time:hasBeginning ?b1. ?te2 time:hasBeginning ?b2. $this time:hasEnd ?e1. ?te2 time:hasEnd ?e2.
							  {?b1 time:inXSDDateTime ?dtb1. ?b2 time:inXSDDateTime ?dtb2. FILTER(?dtb2<?dtb1)}UNION{?b2 time:before ?b1}
							  {?e1 time:inXSDDateTime ?dte1. ?e2 time:inXSDDateTime ?dte2. FILTER(?dte1<?dte2)}UNION{?e1 time:before ?e2}}"""]].


#---------------------------------------------------------------------------------------------------------------------------------------------
# time:intervalDisjoint
#---------------------------------------------------------------------------------------------------------------------------------------------

#The next two rules search for pairs of time:Instant(s) such that (1) each of them belongs to one of the two time:ProperInterval(s) connected 
#by time:intervalDisjoint, and (2) one of the two occurs before the other one. The rules infer that the two time:ProperInterval(s) are
#connected by the same temporal order, which is asserted in terms of the property time:intervalBefore.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalDisjoint;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this time:intervalBefore ?te2}
						WHERE{$this time:intervalDisjoint ?te2.
							  $this (time:hasBeginning|time:hasEnd|time:inside)+ ?i1.
							  ?te2 (time:hasBeginning|time:hasEnd|time:inside)+ ?i2.
							  {?i1 time:inXSDDateTime ?dt1. ?i2 time:inXSDDateTime ?dt2. FILTER(?dt1<?dt2)}UNION{?i1 time:before ?i2}}"""]].
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf time:intervalDisjoint;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{?te2 time:intervalBefore $this}
						WHERE{$this time:intervalDisjoint ?te2.
							  $this (time:hasBeginning|time:hasEnd|time:inside)+ ?i1.
							  ?te2 (time:hasBeginning|time:hasEnd|time:inside)+ ?i2.
							  {?i1 time:inXSDDateTime ?dt1. ?i2 time:inXSDDateTime ?dt2. FILTER(?dt1>?dt2)}UNION{?i2 time:before ?i1}}"""]].


##############################################################################################################################################
#
#	Rules implementing Allen's composition table, as follows:
#	(1) For each asserted property ?atr denoting one of Allen's temporal relations, we connect its subject and object through the reification
#		of the property :hasPossibleATR, in both directions (from the subject to the object and from the object to the subject). In case a 
#		property is connected to itself, the reification is flagged as instance of the special class :ContainsCyclingPath.
#	(2) In cases where two reifications denote two contiguous paths of Allen's temporal properties, we create another reification denoting
#		the conjoined path (note that the reification denoting the inverse path will be likewise created). In case the two contiguous paths
#		have a time:ProperInterval in common (different from the one that conjoins them!) the conjoined path is again flagged as instance of
#		:ContainsCyclingPath. Paths containing cycling paths are no longer reused to create new reifications.
#	(3) We ascribe to the reifications all possible properties denoting Allen's temporal relations that may occur between the pairs of 
#		time:ProperInterval(s).
#		(3.1) For the reifications created in (1), we only add the property ?atr, plus the super- or sub- properties.
#		(3.2) For the reifications created in (2), we use Allen's composition table from the two sub-reifications out of which the ones
#			  in (2) were created.
#	Then, the SHACL shape will check that every reification there is not any asserted property among the two time:ProperInterval(s) that does 
#	not belong to the set of those in :oneOf and that for each reification as instance of :ContainsCyclingPath, one of the properties in this
#	set is time:intervalEquals. The properties that do not comply with these two checks are reported as invalid.
#
##############################################################################################################################################


#For each property denoting one of Allen's temporal relations, the next rule creates the reification of the property :hasPossibleATR 
#connecting the time:ProperInterval(s) in the direction of the Allen's temporal relations as well as the reification of the inverse 
#property :hasPossibleATR (connecting the same time:ProperInterval(s) in opposite direction). The rule connects the reifications to the
#property denoting the Allen's temporal relation via the properties :source and :sourcei and to the two time:ProperInterval(s) via the
#property :includes. Furthermore, if the Allen's temporal relation connects a time:ProperInterval with itself, the rule asserts the two
#reifications as instances of the class :ContainsCyclingPath. Of course the rule triggers only if the two reifications do not already exist.
[rdf:type sh:NodeShape;
	sh:targetClass time:ProperInterval;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{[rdf:type rdf:Statement,?cp; rdf:subject $this; rdf:predicate :hasPossibleATR; rdf:object ?pi2; 
								   :includes $this, ?pi2; :source ?atr].
								  [rdf:type rdf:Statement,?cp; rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object $this; 
								   :includes $this, ?pi2; :sourcei ?atr]}
						WHERE{$this ?atr ?pi2. FILTER(strStarts(str(?atr), "http://www.w3.org/2006/time#interval"))
							  BIND(IF($this=?pi2, :ContainsCyclingPath, rdf:Statement) AS ?cp)
						      NOT EXISTS{?r rdf:type rdf:Statement; rdf:subject $this; rdf:predicate :hasPossibleATR;
										 rdf:object ?pi2; :source ?atr}}"""]].


#The next set of rules, which will be executed after the previous rule, initializes the values of the property :oneOf for the reifications
#created by the previous rule. Specifically, for each pair of reifications created with the previous rule, these rules set the possible 
#properties denoting one of Allen's temporal relations on the bases of :source's and :sourcei's objects.
[rdf:type sh:NodeShape;
	sh:targetClass rdf:Statement;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter, time:intervalDisjoint. 
								  ?thisi :oneOf time:intervalBefore,time:intervalDisjoint}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalAfter.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalAfter}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore, time:intervalDisjoint. 
								  ?thisi :oneOf time:intervalAfter,time:intervalDisjoint}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalBefore.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalBefore}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalDuring, time:intervalIn. ?thisi :oneOf time:intervalContains}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalDuring.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalDuring}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalContains. ?thisi :oneOf time:intervalDuring, time:intervalIn}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalContains.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalContains}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalFinishes, time:intervalIn. ?thisi :oneOf time:intervalFinishedBy}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalFinishes.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalFinishes}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalFinishedBy. ?thisi :oneOf time:intervalFinishes, time:intervalIn}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalFinishedBy.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalFinishedBy}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalStarts, time:intervalIn. ?thisi :oneOf time:intervalStartedBy}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalStarts.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalStarts}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalStartedBy. ?thisi :oneOf time:intervalStarts, time:intervalIn}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalStartedBy.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalStartedBy}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalMeets. ?thisi :oneOf time:intervalMetBy}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalMeets.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalMeets}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalMetBy. ?thisi :oneOf time:intervalMeets}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalMetBy.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalMetBy}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps. ?thisi :oneOf time:intervalOverlappedBy}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalOverlaps.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalOverlaps}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlappedBy. ?thisi :oneOf time:intervalOverlaps}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalOverlappedBy.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalOverlappedBy}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalEquals. ?thisi :oneOf time:intervalEquals}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalEquals.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalEquals}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalDisjoint,time:intervalBefore,time:intervalAfter. 
								  ?thisi :oneOf time:intervalDisjoint,time:intervalBefore,time:intervalAfter}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalDisjoint.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalDisjoint}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalIn,time:intervalStarts,time:intervalFinishes,time:intervalDuring. 
								  ?thisi :oneOf time:intervalStartedBy,time:intervalFinishedBy,time:intervalContains}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2; :source time:intervalIn.
							  ?thisi rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi1; :sourcei time:intervalIn}"""]].


#The next pair of rules triggers whenever there are two reifications describing two *contiguos* paths of Allen's temporal relations, i.e., 
#two paths such that the end of one of the two is the beginning of the other one. The rule having "sh:order 1" creates the reification of the 
#conjoined path. Note that the inverse properties :hasPossibleATR have been also asserted by the first rule in this section; therefore, this rule 
#also creates the reification of the inverse path, but separately. The two reification(s) of the conjoined path are respectively marked as :source1 
#and :source2 in the newly created reification; this will be needed to compute Allen's composition table with the next bunch of rules shown 
#below. Finally, in order to avoid infinite loops, the rule triggers only if: 
# - (1) The reification of the conjoined path (with the same sources) does not already exists.
# - (2) Neither of the two initial reifications contains a cycling path. 
#The created reification will be marked as instance of :ContainsCyclingPath in cases where the two initial reifications have a time:ProperInterval
#in common different from the one that conjoins the two paths. If that's the case, it means that by conjoining the second path to the first one,
#we revisit a time:ProperInterval already visited in the first path, therefore there is a cycle. In order to understand if the two paths have a
#time:ProperInterval in common, we check the time:ProperInterval(s) connected to the two reifications through the property :includes. Therefore, 
#this check is possible only if the two reifications are *first* filled with all the :includes properties and *then* the BIND clause is executed.
#In order to guarantee so in the reifications created by this rule, there is another rule, with "sh:order 1", that includes in the top reification
#any time:ProperInterval included in :source1 or :source2 (i.e., it carries out the union of the two sets). "sh:order 1" guarantees that the rule
#is always executed *before* the one with "sh:order 0".
[rdf:type sh:NodeShape;
	sh:targetClass rdf:Statement;
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules; sh:order 0;
		sh:construct """CONSTRUCT{$this :includes ?pi}WHERE{{$this :source1 ?s}UNION{$this :source2 ?s}. ?s :includes ?pi}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules; sh:order 1;
		sh:construct """CONSTRUCT{[rdf:type rdf:Statement,?cp; rdf:subject ?pi1; rdf:predicate :hasPossibleATR; 
								   rdf:object ?pi3; :source1 $this; :source2 ?r2]}
						WHERE{$this rdf:subject ?pi1; rdf:predicate :hasPossibleATR; rdf:object ?pi2.
							  ?r2 rdf:subject ?pi2; rdf:predicate :hasPossibleATR; rdf:object ?pi3.
							  
							  	#(1) the reification of the conjoined path must not already exist.
							  NOT EXISTS{?r rdf:type rdf:Statement; :source1 $this; :source2 ?r2}
								#(2) neither of the two initial paths are cycling paths.
							  NOT EXISTS{$this rdf:type :ContainsCyclingPath}NOT EXISTS{?r2 rdf:type :ContainsCyclingPath}
			
								#If the two paths share at least one time:ProperInterval, there is cycling path: by adding ?r2 to $this 
								#we revisit a time:ProperInterval that we already visited in $this.
							  BIND(IF(EXISTS{$this :includes ?p. ?r2 :includes ?p. FILTER(?p!=?pi2)}, :ContainsCyclingPath, rdf:Statement) AS ?cp)}"""]].


#The next set of rules implements Allen's composition table. Given a chain of three time:ProperInterval(s) connected by :hasPossibleATR relations, 
#if the reifications of the first two :hasPossibleATR relations are respectively associated with two properties through the property :oneOf, then 
#we use the composition table to infer the properties connected through :oneOf to the reification of the :hasPossibleATR property connecting the 
#first to the third time:ProperInterval.
[rdf:type sh:NodeShape;
	sh:targetSubjectsOf :source1;
	
#The next three rules implement the row of the composition table associated with time:intervalBefore.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
	sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalBefore. 
							  {?r2 :oneOf time:intervalBefore}UNION{?r2 :oneOf time:intervalContains}UNION
							  {?r2 :oneOf time:intervalOverlaps}UNION{?r2 :oneOf time:intervalMeets}UNION
							  {?r2 :oneOf time:intervalStarts}UNION{?r2 :oneOf time:intervalStartedBy}UNION
							  {?r2 :oneOf time:intervalFinishedBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint,time:intervalOverlaps,
								  time:intervalMeets,time:intervalDuring,time:intervalStarts,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalBefore.						  
							  {?r2 :oneOf time:intervalDuring}UNION{?r2 :oneOf time:intervalOverlappedBy}UNION
							  {?r2 :oneOf time:intervalMetBy}UNION{?r2 :oneOf time:intervalFinishes}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalEquals,time:intervalBefore,time:intervalAfter,
								  time:intervalDuring,time:intervalContains,time:intervalStarts, time:intervalStartedBy,
								  time:intervalFinishes,time:intervalFinishedBy,time:intervalOverlaps,time:intervalOverlappedBy,
								  time:intervalMeets,time:intervalMetBy,time:intervalDisjoint,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalBefore. ?r2 :oneOf time:intervalAfter}"""];

#The next three rules implement the row of the composition table associated with time:intervalAfter.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalAfter. 
							  {?r2 :oneOf time:intervalAfter}UNION{?r2 :oneOf time:intervalContains}UNION
							  {?r2 :oneOf time:intervalOverlappedBy}UNION{?r2 :oneOf time:intervalMetBy}UNION
							  {?r2 :oneOf time:intervalStartedBy}UNION{?r2 :oneOf time:intervalFinishes}UNION
							  {?r2 :oneOf time:intervalFinishedBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint,time:intervalOverlappedBy,
								  time:intervalMetBy,time:intervalDuring,time:intervalFinishes,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalAfter.
							  {?r2 :oneOf time:intervalDuring}UNION{?r2 :oneOf time:intervalOverlaps}UNION
							  {?r2 :oneOf time:intervalMeets}UNION{?r2 :oneOf time:intervalStarts}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalEquals,time:intervalBefore,time:intervalAfter,time:intervalDuring,
								  time:intervalContains,time:intervalStarts,time:intervalStartedBy,time:intervalFinishes,
								  time:intervalFinishedBy,time:intervalOverlaps,time:intervalOverlappedBy,time:intervalMeets,
								  time:intervalMetBy,time:intervalDisjoint,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalAfter. ?r2 :oneOf time:intervalBefore}"""];

#The next six rules implement the row of the composition table associated with time:intervalDuring.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalDuring. 
							  {?r2 :oneOf time:intervalBefore}UNION{?r2 :oneOf time:intervalMeets}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalDuring. 
							  {?r2 :oneOf time:intervalAfter}UNION{?r2 :oneOf time:intervalMetBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalDuring,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalDuring. 
							  {?r2 :oneOf time:intervalDuring}UNION{?r2 :oneOf time:intervalStarts}UNION
							  {?r2 :oneOf time:intervalFinishes}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalEquals,time:intervalBefore,time:intervalAfter,
								  time:intervalDuring,time:intervalContains,time:intervalStarts, time:intervalStartedBy,
								  time:intervalFinishes,time:intervalFinishedBy,time:intervalOverlaps,time:intervalOverlappedBy,
								  time:intervalMeets,time:intervalMetBy,time:intervalDisjoint,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalDuring. ?r2 :oneOf time:intervalContains}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint,time:intervalOverlaps,
								  time:intervalMeets,time:intervalDuring,time:intervalStarts,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalDuring. 
							  {?r2 :oneOf time:intervalOverlaps}UNION{?r2 :oneOf time:intervalFinishedBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint,time:intervalOverlappedBy,
								  time:intervalMetBy,time:intervalDuring,time:intervalFinishes,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalDuring. 
							  {?r2 :oneOf time:intervalOverlappedBy}UNION{?r2 :oneOf time:intervalStartedBy}}"""];

#The next six rules implement the row of the composition table associated with time:intervalContains.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint,time:intervalOverlaps,
								  time:intervalMeets,time:intervalContains,time:intervalFinishedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalContains. ?r2 :oneOf time:intervalBefore}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint,time:intervalOverlappedBy,
								  time:intervalContains,time:intervalMetBy,time:intervalStartedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalContains. ?r2 :oneOf time:intervalAfter}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps,time:intervalOverlappedBy,time:intervalDuring,
								  time:intervalIn,time:intervalStartedBy,time:intervalFinishedBy,time:intervalContains,
								  time:intervalFinishes,time:intervalStarts,time:intervalEquals}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalContains. ?r2 :oneOf time:intervalDuring}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalContains}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalContains. 
							  {?r2 :oneOf time:intervalContains}UNION{?r2 :oneOf time:intervalStartedBy}UNION
							  {?r2 :oneOf time:intervalFinishedBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps,time:intervalContains,time:intervalFinishedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalContains. 
							  {?r2 :oneOf time:intervalOverlaps}UNION{?r2 :oneOf time:intervalMeets}UNION
							  {?r2 :oneOf time:intervalStarts}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlappedBy,time:intervalContains,time:intervalStartedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalContains. 
							  {?r2 :oneOf time:intervalOverlappedBy}UNION{?r2 :oneOf time:intervalMetBy}UNION
							  {?r2 :oneOf time:intervalFinishes}}"""];

#The next nine rules implement the row of the composition table associated with time:intervalOverlaps.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalOverlaps.
							  {?r2 :oneOf time:intervalBefore}UNION{?r2 :oneOf time:intervalMeets}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint,time:intervalOverlappedBy,
								  time:intervalContains,time:intervalMetBy,time:intervalStartedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalOverlaps. ?r2 :oneOf time:intervalAfter}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps, time:intervalDuring,time:intervalStarts,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalOverlaps.
							  {?r2 :oneOf time:intervalDuring}UNION{?r2 :oneOf time:intervalFinishes}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint,time:intervalOverlaps,
								  time:intervalMeets,time:intervalContains,time:intervalFinishedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalOverlaps. ?r2 :oneOf time:intervalContains}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint,time:intervalOverlaps, time:intervalMeets}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalOverlaps.
							  {?r2 :oneOf time:intervalOverlaps}UNION{?r2 :oneOf time:intervalFinishedBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps,time:intervalOverlappedBy,time:intervalFinishedBy,
								  time:intervalDuring,time:intervalIn,time:intervalStartedBy,time:intervalContains,
								  time:intervalFinishes,time:intervalStarts,time:intervalEquals}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalOverlaps. ?r2 :oneOf time:intervalOverlappedBy}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlappedBy,time:intervalContains,time:intervalStartedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalOverlaps. ?r2 :oneOf time:intervalMetBy}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalOverlaps. ?r2 :oneOf time:intervalStarts}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalContains,time:intervalOverlaps,time:intervalFinishedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalOverlaps. ?r2 :oneOf time:intervalStartedBy}"""];

#The next nine rules implement the row of the composition table associated with time:intervalOverlappedBy.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint,time:intervalOverlaps,
								  time:intervalMeets,time:intervalContains,time:intervalFinishedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalOverlappedBy. ?r2 :oneOf time:intervalBefore}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalOverlappedBy. 
							  {?r2 :oneOf time:intervalAfter}UNION{?r2 :oneOf time:intervalMetBy}}"""];							  
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlappedBy,time:intervalDuring,time:intervalFinishes,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalOverlappedBy. 
							  {?r2 :oneOf time:intervalDuring}UNION{?r2 :oneOf time:intervalStarts}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint,time:intervalOverlappedBy,
								  time:intervalContains,time:intervalMetBy,time:intervalStartedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalOverlappedBy. ?r2 :oneOf time:intervalContains}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps,time:intervalOverlappedBy,time:intervalDuring,
								  time:intervalIn,time:intervalStartedBy,time:intervalFinishedBy,time:intervalContains,
								  time:intervalFinishes,time:intervalStarts,time:intervalEquals}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalOverlappedBy. ?r2 :oneOf time:intervalOverlaps}"""];							  
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint,time:intervalOverlappedBy,time:intervalMetBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalOverlappedBy. 
							  {?r2 :oneOf time:intervalOverlappedBy}UNION{?r2 :oneOf time:intervalStartedBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps,time:intervalContains,time:intervalFinishedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalOverlappedBy. ?r2 :oneOf time:intervalMeets}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlappedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalOverlappedBy. ?r2 :oneOf time:intervalFinishes}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlappedBy,time:intervalContains,time:intervalStartedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalOverlappedBy. ?r2 :oneOf time:intervalFinishedBy}"""];
							  
#The next five rules implement the row of the composition table associated with time:intervalMeets.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalMeets.
							  {?r2 :oneOf time:intervalBefore}UNION{?r2 :oneOf time:intervalContains}UNION
							  {?r2 :oneOf time:intervalOverlaps}UNION{?r2 :oneOf time:intervalMeets}UNION
							  {?r2 :oneOf time:intervalFinishedBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint,time:intervalOverlappedBy,
								  time:intervalMetBy,time:intervalContains,time:intervalStartedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalMeets. ?r2 :oneOf time:intervalAfter}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps,time:intervalDuring,time:intervalStarts,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalMeets.
							  {?r2 :oneOf time:intervalDuring}UNION{?r2 :oneOf time:intervalOverlappedBy}UNION
							  {?r2 :oneOf time:intervalFinishes}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalFinishes,time:intervalIn,time:intervalFinishedBy,time:intervalEquals}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalMeets. ?r2 :oneOf time:intervalMetBy}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalMeets}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalMeets.
							  {?r2 :oneOf time:intervalStarts}UNION{?r2 :oneOf time:intervalStartedBy}}"""];
							  
#The next five rules implement the row of the composition table associated with time:intervalMetBy.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint,time:intervalOverlaps,
								  time:intervalMeets,time:intervalContains,time:intervalFinishedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalMetBy. ?r2 :oneOf time:intervalBefore}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalMetBy.
							  {?r2 :oneOf time:intervalAfter}UNION{?r2 :oneOf time:intervalContains}UNION
							  {?r2 :oneOf time:intervalOverlappedBy}UNION{?r2 :oneOf time:intervalMetBy}UNION
							  {?r2 :oneOf time:intervalStartedBy}}"""];						  
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalDuring,time:intervalIn,time:intervalFinishes,time:intervalOverlappedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalMetBy.
							  {?r2 :oneOf time:intervalDuring}UNION{?r2 :oneOf time:intervalOverlaps}UNION
							  {?r2 :oneOf time:intervalStarts}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalStarts,time:intervalIn,time:intervalStartedBy,time:intervalEquals}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalMetBy. ?r2 :oneOf time:intervalMeets}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalMetBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalMetBy.
							  {?r2 :oneOf time:intervalFinishes}UNION{?r2 :oneOf time:intervalFinishedBy}}"""];

#The next nine rules implement the row of the composition table associated with time:intervalStarts.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalStarts. 
							  {?r2 :oneOf time:intervalBefore}UNION{?r2 :oneOf time:intervalMeets}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalStarts. ?r2 :oneOf time:intervalAfter}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalDuring,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalStarts.
							  {?r2 :oneOf time:intervalDuring}UNION{?r2 :oneOf time:intervalFinishes}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint,time:intervalOverlaps,
								  time:intervalMeets,time:intervalContains,time:intervalFinishedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalStarts. ?r2 :oneOf time:intervalContains}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint,time:intervalOverlaps,time:intervalMeets}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalStarts.
							  {?r2 :oneOf time:intervalOverlaps}UNION{?r2 :oneOf time:intervalFinishedBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlappedBy,time:intervalDuring,time:intervalFinishes,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalStarts. ?r2 :oneOf time:intervalOverlappedBy}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalMetBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalStarts. ?r2 :oneOf time:intervalMetBy}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalStarts,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalStarts. ?r2 :oneOf time:intervalStarts}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalStarts,time:intervalIn,time:intervalStartedBy,time:intervalEquals}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalStarts. ?r2 :oneOf time:intervalStartedBy}"""];
							  
#The next nine rules implement the row of the composition table associated with time:intervalStartedBy.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint,time:intervalOverlaps,
								  time:intervalMeets,time:intervalContains,time:intervalFinishedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalStartedBy. ?r2 :oneOf time:intervalBefore}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalStartedBy. ?r2 :oneOf time:intervalAfter}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlappedBy,time:intervalDuring,time:intervalFinishes,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalStartedBy. ?r2 :oneOf time:intervalDuring}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalContains}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalStartedBy. 
							  {?r2 :oneOf time:intervalContains}UNION{?r2 :oneOf time:intervalFinishedBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps,time:intervalContains,time:intervalFinishedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalStartedBy. 
							  {?r2 :oneOf time:intervalOverlaps}UNION{?r2 :oneOf time:intervalMeets}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlappedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalStartedBy. 
							  {?r2 :oneOf time:intervalOverlappedBy}UNION{?r2 :oneOf time:intervalFinishes}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalMetBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalStartedBy. ?r2 :oneOf time:intervalMetBy}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalStarts,time:intervalStartedBy,time:intervalIn,time:intervalEquals}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalStartedBy. ?r2 :oneOf time:intervalStarts}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalStartedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalStartedBy. ?r2 :oneOf time:intervalStartedBy}"""];

#The next nine rules implement the row of the composition table associated with time:intervalFinishes.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishes. ?r2 :oneOf time:intervalBefore}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalFinishes. 
							  {?r2 :oneOf time:intervalAfter}UNION{?r2 :oneOf time:intervalMetBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalDuring,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalFinishes. 
							  {?r2 :oneOf time:intervalDuring}UNION{?r2 :oneOf time:intervalStarts}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint,time:intervalOverlappedBy,
								  time:intervalMetBy,time:intervalContains,time:intervalStartedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishes. ?r2 :oneOf time:intervalContains}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps,time:intervalDuring,time:intervalStarts,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishes. ?r2 :oneOf time:intervalOverlaps}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint,time:intervalOverlappedBy,time:intervalMetBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalFinishes. 
							  {?r2 :oneOf time:intervalOverlappedBy}UNION{?r2 :oneOf time:intervalStartedBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalMeets}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishes. ?r2 :oneOf time:intervalMeets}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalFinishes,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishes. ?r2 :oneOf time:intervalFinishes}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalFinishes,time:intervalFinishedBy,time:intervalIn,time:intervalEquals}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishes. ?r2 :oneOf time:intervalFinishedBy}"""];

#The next nine rules implement the row of the composition table associated with time:intervalFinishedBy.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalBefore,time:intervalDisjoint}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishedBy. ?r2 :oneOf time:intervalBefore}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalAfter,time:intervalDisjoint,time:intervalOverlappedBy,
								  time:intervalMetBy,time:intervalContains,time:intervalStartedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishedBy. ?r2 :oneOf time:intervalAfter}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps,time:intervalDuring,time:intervalStarts,time:intervalIn}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishedBy. ?r2 :oneOf time:intervalDuring}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalContains}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalFinishedBy. 
							  {?r2 :oneOf time:intervalContains}UNION{?r2 :oneOf time:intervalStartedBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlaps}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalFinishedBy. 
							  {?r2 :oneOf time:intervalOverlaps}UNION{?r2 :oneOf time:intervalStarts}}"""];							  
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalOverlappedBy,time:intervalContains,time:intervalStartedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishedBy. 
							  {?r2 :oneOf time:intervalOverlappedBy}UNION{?r2 :oneOf time:intervalMetBy}}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalMeets}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishedBy. ?r2 :oneOf time:intervalMeets}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalFinishes,time:intervalFinishedBy,time:intervalIn,time:intervalEquals}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishedBy. ?r2 :oneOf time:intervalFinishes}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf time:intervalFinishedBy}
						WHERE{$this :source1 ?r1; :source2 ?r2. 
							  ?r1 :oneOf time:intervalFinishedBy. ?r2 :oneOf time:intervalFinishedBy}"""];

#The next two rules implement time:intervalEquals: if time:intervalEquals occurs among the possible properties connecting two 
#time:ProperInterval(s) in the sequence, then the possible properties connecting the two time:ProperInterval(s) at the extremes 
#are the possible properties connecting the other two time:ProperInterval(s) in the sequence. Same for the inverse properties.
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf ?any}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r1 :oneOf time:intervalEquals. ?r2 :oneOf ?any}"""];
	sh:rule[rdf:type sh:SPARQLRule; sh:prefixes :PrefixesEmbeddedSPARQLRules;
		sh:construct """CONSTRUCT{$this :oneOf ?any}
						WHERE{$this :source1 ?r1; :source2 ?r2. ?r2 :oneOf time:intervalEquals. ?r1 :oneOf ?any}"""];
].

